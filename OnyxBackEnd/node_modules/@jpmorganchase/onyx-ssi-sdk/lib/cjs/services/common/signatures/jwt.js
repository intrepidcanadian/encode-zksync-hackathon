"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTService = void 0;
const did_jwt_vc_1 = require("did-jwt-vc");
const did_jwt_1 = require("did-jwt");
const utils_1 = require("../../../utils");
const lodash_1 = require("lodash");
const jsonwebtoken_1 = require("jsonwebtoken");
class JWTService {
    constructor() {
        this.name = 'JWT';
    }
    /**
     * Creates a Verifiable Credential JWT given a {@link CredentialPayload} and a {@link DIDWithKeys}.
     *
     * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)
     * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum
     * spec.
     *
     * `DIDWithKeys` is converted to an {@link Issuer} which is then used to sign the JWT.
     *
     *`token`, `Issuer` and `options` are forwarded to {@link createVerifiableCredentialJwt} in did-jwt-vc
    *
    * @param keys - `DIDWithKeys` - the DID and the keypair that will sign the token
    * @param token - `CredentialPayload` - the Credential object
    * @param options - Use these options to tweak the creation of the JWT Credential. These are forwarded to did-jwt.
    * @return a `Promise` that resolves to the JWT encoded verifiable credential
    * Throws `TypeError` if the `payload` is not W3C compliant
    */
    signVC(keys, token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const issuer = this.convertKeys(keys);
            return yield (0, did_jwt_vc_1.createVerifiableCredentialJwt)(token, issuer, options);
        });
    }
    /**
     * Creates a Verifiable Presentation JWT given a {@link PresentationPayload} and a {@link DIDWithKeys}.
     *
     * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)
     * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum
     * spec.
     *
     * `DIDWithKeys` is converted to an {@link Issuer} which is then used to sign the JWT.
     *
     * `token`, `Holder` and `options` are forwarded to {@link createVerifiablePresentationJwt} from did-jwt-vc
     *
     * @param keys - `DIDWithKeys` - the DID and the keypair that will sign the token
     * @param token - `PresentationPayload` - the Presentation object
     * @param options - Use these options to tweak the creation of the JWT Presentation. These are forwarded to did-jwt.
     * @return a `Promise` that resolves to the JWT encoded verifiable presentation
     * Throws `TypeError` if the `payload` is not W3C compliant
     */
    signVP(keys, token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const holder = this.convertKeys(keys);
            return yield (0, did_jwt_vc_1.createVerifiablePresentationJwt)(token, holder, options);
        });
    }
    /**
     * Helper function to convert a {@link DIDWithKeys} to an {@link Issuer}
     *
     * This method transforms the privateKey to a supported Signer based on key algorithm type
     * The Signer is from did-jwt. {@link ES256KSigner} and {@link EdDSASigner} are the spported signers
     *
     * @param keys - `DIDWithKeys` - the DID and the keypair
     * @return an `Issuer` - DID and Signer
     * Throws `TypeError` if supplied key algorithm is not supported
     */
    convertKeys(keys) {
        const pk = keys.keyPair.privateKey;
        const key = (0, lodash_1.isString)(pk) ? (0, did_jwt_1.hexToBytes)(pk.substring(2)) : pk;
        let signer;
        switch (keys.keyPair.algorithm) {
            case utils_1.KEY_ALG.ES256K: {
                signer = (0, did_jwt_1.ES256KSigner)(key);
                break;
            }
            case utils_1.KEY_ALG.EdDSA: {
                signer = (0, did_jwt_1.EdDSASigner)(key);
                break;
            }
            default: {
                throw new TypeError(`${keys.keyPair.algorithm} not supported`);
            }
        }
        const issuer = {
            did: keys.did,
            signer,
            alg: keys.keyPair.algorithm.toString()
        };
        return issuer;
    }
    /**
     * Helper function to decode a JWT
     *
     * This method uses jsonwebtoken to decode a JWT to its {header, payload, signature}
     *
     * @param jwt - JWT string to be decoded
     * @return decoded JWT object {header, payload, signature}
     */
    decodeJWT(token) {
        return (0, jsonwebtoken_1.decode)(token, { complete: true });
    }
}
exports.JWTService = JWTService;
