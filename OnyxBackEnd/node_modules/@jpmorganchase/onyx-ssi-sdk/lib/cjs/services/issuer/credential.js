"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubjectFromVP = exports.getIssuerFromVC = exports.revokeCredential = exports.createAndSignCredentialJWT = exports.createCredentialFromSchema = exports.createCredential = void 0;
const common_1 = require("../common");
/**
 * Creates a {@link CredentialPayload} from supplied Issuer DID, subject DID,
 * subjectData, and CredentialType
 *
 * The Verifiable Credential object created follows the
 * [W3C Verifiable Credential standards](https://www.w3.org/TR/vc-data-model/#basic-concepts)
 * The Verifiable Credential created has not been signed yet.
 *
 * Additional properties can be supplied to this function. These properties should be defined
 * in the W3C spec.
 *
 * @param issuerDID DID of the Issuer
 * @param subjectDID DID of the Subject of the VC
 * @param credentialSubject subject data to be included in the VC
 * @param credentialType type of the VC
 * @param additionalProperties other W3C spec compliant properties of a VC
 * @returns `CredentialPayload` representing the W3C Verifiable Credential object
 */
function createCredential(issuerDID, subjectDID, credentialSubject, credentialType, additionalProperties) {
    let credential = {};
    const currentTimeInSeconds = Math.floor(new Date().getTime() / 1000);
    const validFrom = new Date();
    validFrom.setTime(currentTimeInSeconds * 1000);
    credential["@context"] = [common_1.DEFAULT_CONTEXT];
    credential.credentialSubject = Object.assign({ id: subjectDID }, credentialSubject);
    credential.issuer = { id: issuerDID };
    credential.type = [common_1.VERIFIABLE_CREDENTIAL, ...credentialType];
    credential.issuanceDate = validFrom.toISOString();
    credential = Object.assign(credential, additionalProperties);
    return credential;
}
exports.createCredential = createCredential;
/**
 * Creates a {@link CredentialPayload} from supplied Issuer DID, subject DID,
 * subjectData, and CredentialType, and a VC JSON schema.
 * This method automatically adds the `credentialSchema` property of the VC using the supplied
 * schema location. The type of the credentialSchema is defined by `SCHEMA_VALIDATOR` which
 * should be configurable.
 *
 * The Verifiable Credential object created follows the
 * [W3C Verifiable Credential standards](https://www.w3.org/TR/vc-data-model/#basic-concepts)
 * The Verifiable Credential created has not been signed yet.
 *
 * Additional properties can be supplied to this function. These properties should be defined
 * in the W3C spec.
 *
 * @param schema location of the JSON schema for this credential
 * @param issuerDID DID of the Issuer
 * @param subjectDID DID of the Subject of the VC
 * @param credentialSubject subject data to be included in the VC
 * @param credentialType type of the VC
 * @param additionalProperties other W3C spec compliant properties of a VC
 * @returns `CredentialPayload` representing the W3C Verifiable Credential object with
 * the `credentialSchema` populated
 */
function createCredentialFromSchema(schema, issuerDID, subjectDID, credentialSubject, credentialType, additionalProperties) {
    return __awaiter(this, void 0, void 0, function* () {
        let credential = {};
        const currentTimeInSeconds = Math.floor(new Date().getTime() / 1000);
        const validFrom = new Date();
        validFrom.setTime(currentTimeInSeconds * 1000);
        credential["@context"] = [common_1.DEFAULT_CONTEXT];
        credential.credentialSubject = Object.assign({ id: subjectDID }, credentialSubject);
        credential.issuer = { id: issuerDID };
        credential.type = [common_1.VERIFIABLE_CREDENTIAL, credentialType];
        credential.issuanceDate = validFrom.toISOString();
        credential.credentialSchema = {
            id: schema,
            type: common_1.SCHEMA_VALIDATOR
        };
        credential = Object.assign(credential, additionalProperties);
        return credential;
    });
}
exports.createCredentialFromSchema = createCredentialFromSchema;
/**
 * Creates a Verifiable Credential JWT from {@link DIDWithKeys} and
 * required properties of the Verifiable Credential
 *
 * This method first creates the Credential object from the DID of the Issuer, the DID of the subject,
 * the credentialType and the credentialSubject. This object becomes the payload that is transformed into the
 * [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)
 * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model)
 *
 * The `DIDWithKeys` is used to sign the JWT that encodes the Verifiable Credential.
 *
 * @param issuer
 * @param subjectDID
 * @param credentialSubject
 * @param credentialType
 * @param additionalProperties
 * @param options
 * @returns
 */
function createAndSignCredentialJWT(issuer, subjectDID, credentialSubject, credentialType, additionalProperties, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const payload = yield createCredential(issuer.did, subjectDID, credentialSubject, credentialType, additionalProperties);
        const jwtService = new common_1.JWTService();
        return yield jwtService.signVC(issuer, payload, options);
    });
}
exports.createAndSignCredentialJWT = createAndSignCredentialJWT;
/**
 * This method deactivates an Onyx Verifiable Credential
 *
 * Onyx revocable credentials require the VC to have a DID registered on the DIDRegistry.
 * Revocation involves the Issuer deactivating this DID to revoke the Credential
 *
 * @param vcDID the DID of the Verifiable Credential to be revoked
 * @param didMethod the DID method of the vcDID
 * @returns a `Promise` resolving to if the deactivation succeeded
 * A `DIDMethodFailureError` thrown if the DID method does not support deactivation
 */
function revokeCredential(vcDID, didMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield didMethod.deactivate(vcDID);
    });
}
exports.revokeCredential = revokeCredential;
/**
 * Helper function to retrieve the Issuer DID from a Verifiable Credential
 *
 * @param vc the Verifiable Credential
 * @returns Issuer DID if it exists
 */
function getIssuerFromVC(vc) {
    var _a;
    const jwtService = new common_1.JWTService();
    if (typeof vc === 'string') {
        const credential = (_a = jwtService.decodeJWT(vc)) === null || _a === void 0 ? void 0 : _a.payload;
        return credential.iss;
    }
    else {
        return vc.issuer.id;
    }
}
exports.getIssuerFromVC = getIssuerFromVC;
/**
 * Helper function to retrieve Subject DID from a Verifiable Credential
 *
 * @param vc the Verifiable Credential
 * @returns Subject DID if it exists
 */
function getSubjectFromVP(vc) {
    var _a;
    const jwtService = new common_1.JWTService();
    if (typeof vc === 'string') {
        const credential = (_a = jwtService.decodeJWT(vc)) === null || _a === void 0 ? void 0 : _a.payload;
        return credential.sub;
    }
    else {
        return vc.credentialSubject.id;
    }
}
exports.getSubjectFromVP = getSubjectFromVP;
