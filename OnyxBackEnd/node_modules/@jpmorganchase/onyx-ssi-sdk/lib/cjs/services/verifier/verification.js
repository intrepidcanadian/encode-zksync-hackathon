"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySchema = exports.verifyRevocationStatus = exports.verifyIssuanceDate = exports.verifyExpiry = exports.verifyDIDs = exports.verifyDID = exports.verifyPresentationJWT = exports.verifyCredentialJWT = void 0;
const did_jwt_vc_1 = require("did-jwt-vc");
const common_1 = require("../common");
const did_jwt_1 = require("did-jwt");
const errors_1 = require("../../errors");
/**
 * Provides verification of a Verifiable Credential JWT
 *
 * It uses the {@link verifyCredential} method from did-jwt-vc. This performs JWT
 * validation (digital signature, date verification) and optionally performs format validation
 * of the Verifiable Credential against the W3C standards. The options parameter can be
 * configured to customize what features of the Credential and JWT are validated by the
 * did-jwt-vc and did-jwt packages
 *
 *
 * @param vc {@link VerifiableCredential} to be verified. Either a JWT or W3C VC with proof.
 * @param didResolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document
 *   of the JWT issuer
 * @param options optional tweaks to the verification process
 * @returns a `Promise` that resolves to a boolean or rejects with
 * `TypeError` if the input is not W3C compliant
 * `Error` thrown from did-jwt if any jwt verification fails
 */
function verifyCredentialJWT(vc, didResolver, options
// eslint-disable-next-line  @typescript-eslint/no-explicit-any
) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof vc === 'string') {
            const verified = yield (0, did_jwt_vc_1.verifyCredential)(vc, didResolver, options);
            return verified.verified;
        }
        throw TypeError('Ony JWT supported for Verifiable Credentials');
    });
}
exports.verifyCredentialJWT = verifyCredentialJWT;
/**
 * Provides verification of a Verifiable Presentation JWT
 *
 * It uses the {@link verifyPresentation} method from did-jwt-vc. This performs JWT
 * validation (digital signature, date verification) and optionally performs format validation
 * of the Verifiable Presentation against the W3C standards. The options parameter can be
 * configured to customize what features of the Presentation and JWT are validated by the
 * did-jwt-vc and did-jwt packages.  * This function will not do any validation of the internal
 * VerifiableCredentials except for format validation
 *
 *
 * @param vc {@link VerifiablePresentation} to be verified. Either a JWT or W3C VP with proof.
 * @param didResolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document
 *   of the JWT issuer
 * @param options optional tweaks to the verification process
 * @returns a `Promise` that resolves to a boolean or rejects with
 * `TypeError` if the input is not W3C compliant
 */
function verifyPresentationJWT(vp, didResolver, options
// eslint-disable-next-line  @typescript-eslint/no-explicit-any
) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof vp === 'string') {
            const verified = yield (0, did_jwt_vc_1.verifyPresentation)(vp, didResolver, options);
            return verified.verified;
        }
        throw TypeError('Ony JWT supported for Verifiable Presentations');
    });
}
exports.verifyPresentationJWT = verifyPresentationJWT;
/**
 * Verify that a DID has an active status.
 *
 * Resolves the DID to its DIDDocument and checks the metadata for the deactivated flag
 *
 * true if the DID does not have metadata or deactivated flag isn't on metadata
 * false if deactivated flag set to true
 *
 * @param did the DID to be verified
 * @param didResolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document
 *   of a DID
 * @returns a `Promise` that resolves to if the DID is active
 */
function verifyDID(did, didResolver) {
    return __awaiter(this, void 0, void 0, function* () {
        const didResult = yield didResolver.resolve(did);
        if (didResult.didResolutionMetadata.error) {
            throw new errors_1.DIDMethodFailureError(didResult.didResolutionMetadata.error);
        }
        return !didResult.didDocumentMetadata.deactivated;
    });
}
exports.verifyDID = verifyDID;
/**
 * Verify that all the required DIDs in a {@link VerifiableCredential} exist and have an active status
 *
 * @param vc the Verifiable Credential to verify the Issuer and Subject DIDs
 * @param didResolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document
 *   of a DID
 * @returns a `Promise` that resolves to if the Credential DIDs are valid
 */
function verifyDIDs(vc, didResolver) {
    return __awaiter(this, void 0, void 0, function* () {
        let issuer;
        let holder;
        if (typeof vc === 'string') {
            const credential = (0, did_jwt_1.decodeJWT)(vc).payload;
            issuer = credential.iss;
            holder = credential.sub;
        }
        else {
            issuer = vc.issuer.id;
            holder = vc.credentialSubject.id;
        }
        if (issuer && holder) {
            const issuerVerified = yield verifyDID(issuer, didResolver);
            const holderVerified = yield verifyDID(holder, didResolver);
            return issuerVerified && holderVerified;
        }
        return false;
    });
}
exports.verifyDIDs = verifyDIDs;
/**
 * Verify the expiration date of a {@link VerifiableCredential}
 *
 * @param vc `VerifiableCredential` to be verified
 * @returns boolean determining if the expirationDate is valid
 */
function verifyExpiry(vc) {
    let expiryDate;
    if (typeof vc === 'string') {
        const credential = (0, did_jwt_1.decodeJWT)(vc).payload;
        if (!credential.exp) {
            throw new Error('No Expiration Date in JWT');
        }
        expiryDate = credential.exp * 1000;
    }
    else {
        expiryDate = vc.expirationDate;
    }
    if (expiryDate) {
        const currentDate = new Date();
        return currentDate < new Date(expiryDate);
    }
    return false;
}
exports.verifyExpiry = verifyExpiry;
/**
 * Verify the issuance date of a {@link VerifiableCredential}
 *
 * @param vc `VerifiableCredential` to be verified
 * @returns boolean determining if the issuanceDate is valid
 */
function verifyIssuanceDate(vc) {
    let issuanceDate;
    if (typeof vc === 'string') {
        const credential = (0, did_jwt_1.decodeJWT)(vc).payload;
        if (!credential.nbf) {
            throw new Error('No Issuance Date in JWT');
        }
        issuanceDate = credential.nbf * 1000;
    }
    else {
        issuanceDate = vc.issuanceDate;
    }
    if (issuanceDate) {
        const currentDate = new Date();
        return new Date(issuanceDate) <= currentDate;
    }
    return false;
}
exports.verifyIssuanceDate = verifyIssuanceDate;
/**
 * Verify the revocation status of an Onyx revocable Verifiable Credential
 *
 * True if VC not revoked, false if revoked
 *
 * @param vc VerifiableCredential` to be verified
 * @param didResolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document
 *   of a DID
 * @returns a `Promise` that resolves to if the Verifiable Credential is active.
 */
function verifyRevocationStatus(vc, didResolver) {
    return __awaiter(this, void 0, void 0, function* () {
        let vcId;
        if (typeof vc === 'string') {
            const credential = (0, did_jwt_1.decodeJWT)(vc).payload;
            vcId = credential.jti ? credential.jti : credential.vc.id;
        }
        else {
            vcId = vc.id;
        }
        if (vcId) {
            return yield verifyDID(vcId, didResolver);
        }
        return false;
    });
}
exports.verifyRevocationStatus = verifyRevocationStatus;
/**
 * Verify that the `credentialSubject` conforms to the defined JSON Schema present
 * in the Verifiable Credential
 *
 * @param vc VerifiableCredential` to be verified
 * @param isFile boolean if the schema location is a local file
 * @returns a `Promise` that resolves to if the schema check succeeded
 */
function verifySchema(vc, isFile) {
    return __awaiter(this, void 0, void 0, function* () {
        let credSchema;
        let credSubject;
        if (typeof vc === 'string') {
            const credential = (0, did_jwt_1.decodeJWT)(vc).payload;
            credSchema = credential.vc.credentialSchema;
            credSubject = credential.vc.credentialSubject;
        }
        else {
            credSchema = vc.credentialSchema;
            credSubject = vc.credentialSubject;
        }
        if (credSchema) {
            const schema = isFile ?
                yield common_1.SchemaManager.getSchemaFromFile(credSchema)
                : yield common_1.SchemaManager.getSchemaRemote(credSchema);
            return common_1.SchemaManager.validateCredentialSubject(credSubject, schema);
        }
        return false;
    });
}
exports.verifySchema = verifySchema;
