"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KEY_ALG = exports.KeyUtils = void 0;
const secp256k1_1 = require("secp256k1");
const lodash_1 = require("lodash");
const errors_1 = require("../errors");
class KeyUtils {
    /**
     * Returns the public key for the given private key
     * @param {string} privateKey the private key for which to find the public key for
     * @returns {string} the public key in hex
     */
    static privateKeyToPublicKey(privateKey) {
        if (!this.isHexPrivateKey(privateKey)) {
            throw new errors_1.KeyTypeError('private key should be hex');
        }
        const noprefixPrivateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;
        const privateKeyBuffer = Buffer.from(noprefixPrivateKey, 'hex');
        return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKeyBuffer)).toString('hex');
    }
    /**
     * Checks if given private key is in hex format
     * @param key private key
     * @returns true if private key in hex format, false otherwise
     */
    static isHexPrivateKey(key) {
        if (!(0, lodash_1.isString)(key)) {
            return false;
        }
        const hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;
        return hexMatcher.test(key);
    }
    /**
     * Checks if given public key is in hex format
     * @param key public key
     * @param strict if public key needs 0x prefix
     * @returns true if public key in hex format, false otherwise
     */
    static isHexPublicKey(key, strict = false) {
        if (!(0, lodash_1.isString)(key)) {
            return false;
        }
        const hexMatcher = strict ? /^(0x)([a-fA-F0-9]{66})$/ : /^(0x)?([a-fA-F0-9]{66})$/;
        return hexMatcher.test(key);
    }
    /**
     * Checks if given private key is bytes
     *
     * @param key private key
     * @returns true if private key is correct number of bytes
     */
    static isBytesPrivateKey(key) {
        return !(0, lodash_1.isString)(key) && key.length === KeyUtils.PRIVATE_KEY_LENGTH;
    }
    /**
     * Checks if given public key is bytes
     *
     * @param key public key
     * @returns true if public key is correct number of bytes
     */
    static isBytesPublicKey(key) {
        return !(0, lodash_1.isString)(key) && key.length === KeyUtils.PUBLIC_KEY_LENGTH;
    }
}
KeyUtils.PUBLIC_KEY_LENGTH = 32;
KeyUtils.PRIVATE_KEY_LENGTH = 64;
exports.KeyUtils = KeyUtils;
/**
 * ENUM for the keyPair algorithms supported in this SDK
 * ES256K is for use with did:ethr
 * EdDSA is for use with did:key
 */
var KEY_ALG;
(function (KEY_ALG) {
    KEY_ALG["ES256K"] = "ES256K";
    KEY_ALG["EdDSA"] = "EdDSA";
})(KEY_ALG = exports.KEY_ALG || (exports.KEY_ALG = {}));
