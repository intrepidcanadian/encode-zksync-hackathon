import { publicKeyCreate } from 'secp256k1';
import { isString } from 'lodash';
import { KeyTypeError } from '../errors';
class KeyUtils {
    static PUBLIC_KEY_LENGTH = 32;
    static PRIVATE_KEY_LENGTH = 64;
    /**
     * Returns the public key for the given private key
     * @param {string} privateKey the private key for which to find the public key for
     * @returns {string} the public key in hex
     */
    static privateKeyToPublicKey(privateKey) {
        if (!this.isHexPrivateKey(privateKey)) {
            throw new KeyTypeError('private key should be hex');
        }
        const noprefixPrivateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;
        const privateKeyBuffer = Buffer.from(noprefixPrivateKey, 'hex');
        return Buffer.from(publicKeyCreate(privateKeyBuffer)).toString('hex');
    }
    /**
     * Checks if given private key is in hex format
     * @param key private key
     * @returns true if private key in hex format, false otherwise
     */
    static isHexPrivateKey(key) {
        if (!isString(key)) {
            return false;
        }
        const hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;
        return hexMatcher.test(key);
    }
    /**
     * Checks if given public key is in hex format
     * @param key public key
     * @param strict if public key needs 0x prefix
     * @returns true if public key in hex format, false otherwise
     */
    static isHexPublicKey(key, strict = false) {
        if (!isString(key)) {
            return false;
        }
        const hexMatcher = strict ? /^(0x)([a-fA-F0-9]{66})$/ : /^(0x)?([a-fA-F0-9]{66})$/;
        return hexMatcher.test(key);
    }
    /**
     * Checks if given private key is bytes
     *
     * @param key private key
     * @returns true if private key is correct number of bytes
     */
    static isBytesPrivateKey(key) {
        return !isString(key) && key.length === KeyUtils.PRIVATE_KEY_LENGTH;
    }
    /**
     * Checks if given public key is bytes
     *
     * @param key public key
     * @returns true if public key is correct number of bytes
     */
    static isBytesPublicKey(key) {
        return !isString(key) && key.length === KeyUtils.PUBLIC_KEY_LENGTH;
    }
}
export { KeyUtils };
/**
 * ENUM for the keyPair algorithms supported in this SDK
 * ES256K is for use with did:ethr
 * EdDSA is for use with did:key
 */
export var KEY_ALG;
(function (KEY_ALG) {
    KEY_ALG["ES256K"] = "ES256K";
    KEY_ALG["EdDSA"] = "EdDSA";
})(KEY_ALG || (KEY_ALG = {}));
